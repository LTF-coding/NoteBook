相位函数$\Theta(p,\beta)$: **核心亮点**
可以理解为网络权重$\alpha$生成器即 $\alpha = \Theta(p,\beta)$ ，PFNN由四个网络权重控制分别表示四个相位$\beta = \{\alpha_0, \alpha_1, \alpha_2, \alpha_3\}$，对于每一帧模型的权重均由四个相位的模型权重通过一个**立方Catmull-Rom**样条插值计算出来
+ 相位函数**强制网络学习周期性运动的内在规律**（如步态中摆动腿与支撑腿的交替），提升动作的连贯性。避免连续混合输入带来的**相位混合​**。
+ 提升训练稳定性​，传统神经网络若将相位作为输入特征，可能因Dropout或噪声导致相位信息被忽略。PFNN通过相位函数直接控制所有权重**​隐式相位建模​**​，确保相位的主导作用。​实验表明，PFNN对相位的敏感度（输出关于相位的梯度）是传统方法的50倍以上，证明相位函数有效传递了时间信息。
+ **紧凑表示**，仅需存储4个控制点（约10MB），即可表达复杂的周期性运动模式。

**训练阶段**
输入$X_i$: 
+ (**Character**) positions and velocities of character local to the root transform in previous frame. 仅先前帧
  1. *local joint positions*  $j^p_{i-1} \in  \mathbb{R}^{3j}$
  2. *local joint velocities*  $j^v_{i-1} \in  \mathbb{R}^{3j}$
+ (**User Control**) a local window centered at frame i and  sampled surrounding frames covering 1 second of motion in the past and 0.9 seconds of motion in the future.  在关键帧周围窗口(t=12)采样相关参数
  1. *trajectory positions*  $t^p_i \in  \mathbb{R}^{2t}$ 
  2. *trajectory directions* $t^d_i \in  \mathbb{R}^{2t}$ 
  3. *trajectory heights* $t^h_i \in  \mathbb{R}^{3t}$
  4. *trajectory semantic variables* $t^g_i \in  \mathbb{R}^{5t}$   五维向量表示gait和其他信息
     + standing,
     + walking,
     + jogging, 
     + jumping, 
     + crouching

输出$Y_i$: 
	 *the state of the character in the current frame*,
	 *the change in phase, the movement of the root transform*, 
	 *a prediction of the trajectory in the next frame*, 
	 *contact labels for the feet joints for use in IK post-processing*.
1. *predicted trajectory positions* $t^p_{i+1} \in  \mathbb{R}^{2t}$
2. *predicted trajectory directions* $t^d_{i+1} \in  \mathbb{R}^{2t}$
3. *local joint positions*  $j^p_{i} \in  \mathbb{R}^{3j}$
4. *local joint velocities*  $j^v_{i} \in  \mathbb{R}^{3j}$ 
5. *the joint angles local to the character root transform expressed using the exponential map* $j^v_{i} \in  \mathbb{R}^{3j}$ 
6. *root transform translational x velocity*  $r^x_{i} \in  \mathbb{R}$
7.  *root transform translational z velocity* $r^z_{i} \in  \mathbb{R}$
8.  *root transform angular velocity around the upward direction* $r^a_{i} \in  \mathbb{R}$
9.  *the change in phase*  $p_{i} \in  \mathbb{R}$
10. *foot contact labels*   $c_{i} \in  \mathbb{R}^4$

损失函数Cost：
$$
\begin{equation} 
\mathcal{L}(X, Y, P;\beta) = \| Y - \Phi(X; \Theta(P;\beta)) \|_2^2 + \gamma \|\beta\|_1 
\end{equation}
$$
+ 第一项预测结果的MSE Loss
+ 正则项，网络的参数大小，避免参数过大

**RUNTIME:**
1. **Future Trajectories $t_p$ $t_d$ :** the future elements of the trajectory $t_p$ $t_d$ are computed by blending **the trajectory estimated from the game-pad control stick** $a_0$ and **those generated by the PFNN in the previous frame** $a_1$.$$TrajectoryBlend(a_0,a_1,t,\tau) = (1-t^{\tau})a_0 + t^{\tau}a_1,$$
	+ 对于未来轨迹 $t_p$ $t_d$的预测由上述公式确定，由两部分组成分别是游戏控制杆的预测的轨迹$a_0$和PFNN由先前帧预测出来的轨迹$a_1$，两者由一个控制因子$\tau$控制，$t \in [0,1]$ 随着轨迹的距离增大。
	+ 在本文中$\tau_d = 2.0, \tau_v = 0.5$   这会产生一个看起来自然却保持响应速度的角色，因为大多数感知的响应能力源于角色迅速响应所需的方向变化。在角色面朝方向上提高控制因子的权重可以使角色对于控制更快的响应。

2. **Semantic Information$t_g$:**  These are all set either by **user interaction** (e.g. we use the right shoulder button of the game-pad to indicate the gait should switch to a jog), or by checking the location of the trajectory against **elements of the environment** (e.g. when the trajectory passes over certain areas the variable indicating a jumping motion is activated). 
	+ 由**用户交互**和**环境交互**决定
3. **Trajectory Heights** $t^h$： project the trajectory locations vertically onto the scene geometry and extract the heights to prepare $t_h$ .
	+ 在上述操作完成后讲轨迹沿垂直投影到地面得到
4. **Output $y$**: These joint transforms $j^p, j^a$ are then edited to avoid foot sliding using a simple twojoint IK along with the contact labels $c$. The root transform position and rotation is updated using the predicted root translational and rotational velocities $r^x, r^z, r^a$ . This completes the runtime process for an individual frame.
	+ PFNN预测得到关键点的位置和角度后通过脚底是否接触地面的标记c进行IK计算避免脚底滑动
	+ 根节点的位置和旋转通过预测出来的根节点变换和旋转变量计算
	+ 这些计算在运行时每帧会独立计算

